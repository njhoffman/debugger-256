#!/usr/bin/env node

// opens a stream for piping output into
// to preserve incoming ansi colors use 'unbuffer' in expect package

const createDebug = require('../lib/debugger');
const _ = require('lodash');
const fs = require('fs');
const argv = require('minimist')(process.argv.slice(2));

let subsystems = [];

const renderLine = (line) => {
  try {
    line = JSON.parse(line);
  } catch(e) {
    if (line.trim().length > 0) {
      console.log(line);
    }
    return;
  }
  //
  let subsystem = line.name ? line.name : '';
  subsystem += line.subsystem ? ' ' + line.subsystem : '';

  let level = 'info';
  if (line.level && /(_dbg|fatal|error|warn|log|info|debug|trace)/.test(line.level)) {
    level = line.level;
  } else if (_.isNumber(line.level)) {
    // bunyan log levels
    level = line.level === 60
      ? 'fatal' : line.level === 50
      ? 'error' : line.level === 40
      ? 'warn'  : line.level === 20
      ? 'debug' : line.level === 10
      ? 'trace' : line.level < 10
      ? 'silly' : 'info';
  }

  const debugLine = createDebug(subsystem);
  const message = line.msg ? line.msg : line.message ? line.message : '';

  if (_.isEmpty(line)) {
    debugLine[level](message);
  } else {
    debugLine[level](message, line);
  }
};

if (argv._.length) {
  // First parameter is the file to read and parse
  let filename = argv._[0];
  try {
    fs.readFileSync(filename, 'utf8').forEach(renderLine);
  } catch (e) {
    console.error('Error reading: ' + filename );
    console.error(e);
    console.error(e.stack);
    process.exit(1);
  }
} else {
  // Read input stream

  let streamData = '';

  process.stdin.resume();
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', (chunk) => {
    if (chunk === '\n') {
      renderLine(streamData);
      streamData = '';
      return;
    } else if (/\n$/.test(chunk)) {
      streamData += chunk;
      streamData.split('\n').forEach(renderLine);
      streamData = '';
      return;
    }
    streamData += chunk;
  });
  process.stdin.on('end', function(){
    renderLine(streamData);
  });
}
